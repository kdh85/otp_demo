# OTP 번호 생성 및 인증하기
## OTP 요건.
* 4자리의 정수를 각 사용자에게 중복없이 고유하게 할당함.
* 발급된 번호의 만료시간은 3분을 기준으로 설정.
* 3분이내에 발급된 번호와 인증요청된 번호가 일치하면 해당 번호 발급을 회수 후 다음 사용자에게 재발급.

## 전체 시나리오.
* 사용자가 앱을 로그인.
* 정맥 단말기에서 정맥을 등록 시도시 앱의 OTP값을 요청.
* 정맥 단말기에 앱에서 제공하는 OTP값을 입력 후 검증 시도후 성공/실패 케이스 진행.
  * 성공
    * 발급된 OTP 번호를 redis 에서 제거.
    * 성공값을 return.
  * 실패 
    * 발급된 OTP 키값의 유효시간이 남은 경우
      * 발급된 OTP값을 redis에서 유지.
      * 불일치로 인한 실패를 return.
    * 입력하는 순간 OTP가 갱신되어 불일치하게 되는 경우.
      * 갱신된 발급된 OTP값을 redis에서 유지.
      * 불일치로 인한 실패를 return.
## 기능 항목
* 번호 생성.
  * 0 ~ 9999 까지의 자연수를 생성.
  * 번호의 포맷은 4자리를 전부 채우는 형식 ex) 0000, 0010, 9900
  * 생성된 번호들 중에서 하나를 발급.
* 번호 발급 및 회수.
  * 사용가능 번호 배열에 생성된 번호들을 담고 순차적으로 꺼냄.
  * 사용이 만료된 번호를 대기열로 반환.
* 사용자.
  * 입력필드 구성 : Id, name, age, mobile
    * uuid로 Id를 발급.
* 가맹점
  * 가맹점 Id를 발급.
* 사용자-가맹점 연결.
  * 사용자:가맹점 관계는 1:N으로 구성.
* OTP 발급 객체
  * 입력필드 구성 : userId, 가맹점Id, 발급된 4자리 자연수, 생성시간, 만료시간
  * 중복 발급 불가.ex) 0099가 발급된 상태라면 재차 요청시 0099가 발급이 불가해야함.
  * 가맹점ID+발급된번호를 합성하여 고유한 인증키를 생성.
    * 순수 숫자로만 키를 생성하면 생성되는 키의 길이에 따라 사용자의 풀이 제한되는 구조적 제한이 생김.
    * 사용자별 고유한 인증키값을 생성하되, 고유생성 인증키가 반복되지 않게 생성되기 위해서 발부된 번호의 중복성을 제거하고 가맹점Id를 합성하여 유니크키를 생성.
* 인증 서비스
  * 사용자별 OTP 발급
    * 인증요청이 들어오면 OTP 발급 객체를 생성후 redis에 등록.
  * 미인증으로 인한 OTP 재발급.
    * 기존 OTP가 발급된 사용자가 제한시간(3분) 이내 인증에 실패할 경우, 연속으로 다음 OTP번호를 발급.
  * 사용자별 OTP 인증
    * 사용자가 앱에서 노출된 OTP 번호를 입력하여 인증 요청이 들어오면 redis에 등록된 인증정보와 일치여부를 검증
      * 일치하면 redis에 저장되있는 발급된 OTP 번호를 회수.
      * 일치하지 않으면 인증실패 반환하고 해당 키값은 유지.
* redis 데이터 관리
  * 생성시 OTP에서 설정한 유지시간을 기준으로 expire값을 설정하여 OTP 검증 key에 대한 검증사용자 정보를 value 에 등록.
  * 인증 요청이 들어와서 일치하는 결과가 반환될 경우, 해당 값은 잔여 만료시간과 무관하게 제거.
  * 생성된 인증 대조 데이터 expire 설정대로 자동 소거.